### Item57 - 지역변수의 범위를 최소화하라

`객체지향`적으로 설계하기 위해서는 모듈간 의존성을 최대한 낮춰야 한다  
따라서 지역변수의 범위를 최소화하는 것은 너무나 중요하다  
**지역변수의 범위를 줄이은 가장 강력한 기법은 역시 '가장 처음 쓰일 때 선언하기'다**  
또한, 지역변수는 선언과 동시에 초기화 하자!  
순회하는 반복문을 예시로 들어보자
```java
Iterator<Element> i = c.iterator();
while (i.hasNext()) {
	dosomething(i.next());
}

Iterator<Element> i2 = c2.iterator();
while (i.hasNext()) { // 버그!!!!
	dosomething(i2.next());
}
```
순회 반복문을 copy & paste 하다가 실수로 놓쳐서 버그가 발생한 코드다  
그러니 꼭, 지역변수의 범위는 넓게 사용하지 말자(여기서 지역변수 i)  
```text
지역변수의 범위를 최소화하기 위해서는 메서드를 작게 유지하고 한 가지 기능에 집중하는 것이다
```

### Item58 - 전통적인 for문보다는 for-each문을 사용하라

이전 Item에서 구닥다리 순회방식 쓰다가 `버그`가 발생한 것을 기억하는가?  
전통적인 방법의 반복문보다는 `for-each`문을 애용하자  
나는 2중 중첩 for문을 작성하고자 한다. 다음 코드를 보자  
```java
List<Card> deck = new ArrayList<>();
for (Iterator<Suit> i = suits.iterator(); i.hasNext(); )
	for (Iterator<Rank> j = ranks.iterator(); j.hasNext(); ) 
		deck.add(new Card(i.next(), j.next()));
```
무엇이 문제인지 보이는가?  
위 코드의 문제점은 `Rank`의 첫번째 순회가 끝나면 모든 순회가 끝나버린다  
사실 의도한 코드는 이것일 것이다
```java
for (Suit suit : suits)
	for (Rank rank : ranks)
		deck.add(new Card(suit, rank));
```
안타깝게도 이렇게 좋은 `for-each`를 사용하지 못하는 상황도 존재한다  
1. 파괴적인 필터링 - 컬렉션을 순회하면서 원소를 제거할 때
2. 변형 - 리스트를 순회하면서 원소의 값을 수정해야 할 때
3. 병렬 반복 - 여러 컬렉션을 병렬로 순회해야 할 때
항상 **상황**에 맞는 최선을 택하는 여러분이 되길 바란다  


### Item59 - 라이브러리를 익히고 사용하라 

이미 자주 사용하고 있는 **기능**의 경우 이미 구현되어 있는게 많다  
여러분들이 직접 구현한 것보다는 `검증`받은 라이브러리를 적극적으로 활용하자  
**표준 라이브러리를 사용하면 그 코드를 작서안 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다**  
적어도 `java.lang` , `java.util`, `java.io` 에 대해서는 익숙해지자  
아파치 재단의 `lang3`와 구글의 `guava`도 많이 유용하니 참고하라!  
```text
이미 발명된 바퀴를 다시 발명하지 말자
```


### Item60 - 정확한 답이 필요하다면 float와 double은 피하라

float와 double은 `근사치`를 계산하도록 설계되었다  
```java
System.out.println(1.03 - 0.42);
```
이 코드는 원래 정답은 0.61이나 돌려보면 아쉽게도 `0.61000000000000001`을 출력한다  
이러한 계산에는 반드시 `BigDecimal` 혹은 `int` , `long`을 사용해서 변환해서 계산해야 한다!  
다만 `BigDecimal`은 성능 저하가 따라오니, 이를 회피하고 싶다면 `int`, `long`을 적극적으로 활용하자!  


### Item61 - 박싱된 기본 타입보다는 기본 타입을 사용하라

박싱된 기본 타입은 정말 좋지 않다  
코드를 통해 바로 예시로 알아보자  
```java
Comparator<Integer> naturalOrder = (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
naturalOrder.compare(new Integer(42), new Integer(42));
```
이렇게 하게되면 어떻게 될까?  
유감스럽게도 `1`로 리턴받게 된다  
`i < j`는 정상적으로 숫자비교가 이루어지나, `i==j`는 객체간 래퍼런스 비교를 하게되서 거짓을 반환한다  
그래서 반드시 기본 타입으로 지정한뒤 비교해야 한다!  
또한 박싱된 기본 타입은 **초기화**하지 않으면 `NullPointerException`을 던지니 절대 쓰지 말자  
마지막으로 박싱된 기본 타입으로 `+=` 연산을 계속 하게 되면 객체를 끊임없이 계속 생성한다ㅠㅠ  
**박싱된 기본 타입**은 `원소,키,값`으로 쓸 때가 아니면 쓰지 말자  


### Item62 - 다른 타입이 적절하다면 문자열 사용을 피하라

* 문자열로 다른 값 타입을 대신하지 말자
* 문자열로 열거 타입을 대신하지 말자
* 문자열로 혼합 타입을 대신하지 말자
* 문자열로 권한을 표현하지 말자


### Item63 - 문자열 연결은 느리니 주의하라

문자열 연결을 반복 `+=`을 하게 되면 **객체를 계속 생성하는 꼴**이다  
반드시 `StringBuilder` 혹은 `StringBuffer`를 활용하자!  
시간상으로 O(n)과 O(n^2)의 차이이니 주의하자  


### Item64 - 객체는 인터페이스를 사용해 참조하라

객체지향의 규칙과 같은 설명이다  
`객체`는 반드시 **구체적**인 객체보다 **추상적**인 객체에 더 의존해야 한다!  
```java
LinkedHashSet<String> nameSet = new LinkedHashSet<>();  // 절대 이렇게 ㄴㄴ
Set<String> nameSet = new LinkedHashSet<>();
``` 
인터페이스를 타입으로 사용하는 습관을 길러두면 프로그램이 훨씬 유연해진다  


### Item65 - 리플렉션보다는 인터페이스를 사용하라

제목이 곧 내용!

### Item66 - 네이티브 메서드는 신중히 사용하라

`제곧내`

### Item67 - 최적화는 신중히 하라

빠른 성능을 위해서 `견고한 구조`를 희생하지는 마라  
**빠른 프로그램보다는 좋은 프로그램을 작성하라**  
또한 `API 설계`할 때 성능에 주는 영향을 고려하라  
성능을 위해 `API`를 왜곡하는 건 매우매우 좋지 않다!!  
잭슨이 소개한 최적화 규칙은 다음과 같다  
1. 하지 마라
2. 아직 하지 마라
사실 알고리즘 문제를 풀면 알겠지만 성능이 안좋은건 사소한 부분이 아니라 `큰 그림`을 놓치고 있다는 증거다  
`성능 최적화`를 실시했으면 반드시 비교전후 **test**를 실시하자


### Item68 - 일반적으로 통용되는 명명 규칙을 따르라

보통 공통적으로 통용되는 규칙들이 있다  
[구글 Java Style Guide](https://google.github.io/styleguide/javaguide.html#s5-naming)를 따르자!  
